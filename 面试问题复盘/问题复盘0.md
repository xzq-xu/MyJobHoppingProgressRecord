# 面试问题复盘

## JAVA部分

### 基础概念

- 重载和重写的区别
- 创建线程池的核心参数
- 单个线程的线程池有什么用处
  

### 使用

- Stream流的使用
  


### 进阶

#### 关于JDK的新特性

了解了一些关于JDK17的新特性
- switch增强，增强的switch可以作为表达式
- 文本块
- 模式匹配， instanceof 增强
- Records 类 创建不可变的数据载体类 它可以自动生成构造函数、getter方法、equals()、hashCode()和toString()方法等
- 密封类：限制了其他类或接口继承或者实现他的能力 `sealed`
- jdk17模块化机制
- 对于NPE报错的增强


#### 关于GC了解多少

##### 堆内存结构
在JDK8中，堆内存被分为年轻代和老年代。年轻代被进一步分为Eden区和Survivor区
创建对象时优先在年轻代中创建，在经历过多次（一般为16）垃圾回收后，将还存活的对象放入老年代
其中年轻代一般采用标记复制算法，由Eden区+其中一块Survivor区 与 另一块Survivor区做标记复制

##### 如何发现垃圾

- 引用计数算法
为每个对象维护一个引用计数器，每当有一个地方引用该对象时，计数器加一，引用失效计数器减一。当引用计数器为0时表示该对象不可达，即为垃圾对象。

存在问题： 无法处理循环引用的情况，两个对象相互引用但又没有外部引用，也不会被认为是垃圾对象

- 可达性分析算法
将所有的引用关系看作一张图（MAP）,从“GC ROOTs”出发开始向下搜索，搜索所走过的路径被称为引用链。 当一个对象到 GC ROOTS 没有任何引用链相连时，则该对象不可达，即为垃圾对象。
**GCRoots**： 虚拟机栈中的引用的对象，本地方法栈中引用的对象，方法区中静态变量引用的对象，常量引用的对象

##### 垃圾回收算法

- 标记-清除
分为标记和清除两个阶段。首先标记出所有[不]需要回收的对象（GCroots出发标记），标记完成后统一清理[没有]被标记的对象

存在问题： 清除后容易产生内存碎片

- 标记-复制
一般用在年轻代，将内存分为大小相等的两块，每次只使用其中一块。垃圾回收时，将还存活的对象复制到另一块内存上，然后将原来的内存一次性释放

存在问题：内存利用率不高，只有原来的一半。年轻代对象一般都是朝生夕死，这个缺点尚可接受

- 标记-整理
在标记-清除的基础加了一步整理，在标记完成后移动对象整理内存空间并回收垃圾对象

存在问题：效率不高，一般用在老年代


##### 垃圾收集器

###### CMS
工作流程：初始标记，并发标记，重新标记，并发清除
初始标记和重新标记都会触发stw
初始标记仅标记与GCRoots直接相连的对象stw较短
并发标记（三色标记法）和用户线程同时进行，不存在stw
重新标记 由于并发标记与用户线程同时进行可能会导致对象引用关系发生变化，重新标记来矫正这些变化，stw较短
并发清除 与用户线程同时进行，回收标记好的垃圾对象

存在问题：采用标记-清除算法，容易产生内存碎片，当碎片过多时可能会导致提前触发fullGC



###### G1

G1将堆内存分为多个大小相等的region，这些region不明确划分为年轻代和老年代，而是每个region都可以根据需要当成年轻代或是老年代的角色。

工作流程类似CMS
初始标记，并发标记，最终标记，筛选回收
其中 并发标记是基于region进行标记
筛选回收时，会根据用户设定的stw时间，对被扫描的区域做价值评估，优先回收部分区域，以满足stw时间的需求

回收时采用了标记-复制算法，直接从这块region复制到新的region，避免内存碎片的产生
另外对于大对象使用一块专门的region（属于老年代）存放，存储独立，被回收之前都不会移动。


存在问题： 如果gc时间设置的过短可能会频繁触发gc导致降低吞吐量


###### ZGC
ZGC的标记阶段由多个小阶段组成，部分小阶段需要暂停用户线程，但整体停顿时间较短
采用染色指针技术来进行标记，能够在更大的堆内存范围内高效的标记存活对象，并且尽量减少对应用程序的影响

初始标记，并发标记，再标记，并发转移准备，初始转移，并发转移

再标记：如果再并发标记阶段有新的对象被创建或有对象被回收，ZGC需要一次短暂的stw再标记，修正有于并发引起的标记不一致问题

并发转移准备：扫描整个堆，确定收集哪些Region，并将这些Region组成重分配集合。这里与G1不一样的是，ZGC会扫描所有的Region。 这个过程不是为了计算最优的回收集合，而是确定存活对象将被复制到其他Region

初始转移：核心阶段， ZGC并发地将重分配集合中存活的对象复制到新的Region。同时为了记录从旧对象到新对象的转移关系，ZGC需要为重分配集合中的每个Region维护一个转发表

并发转移： 修正堆中指向重分配集合中的旧对象的所有引用，真正对对象引用进行修复的一个步骤。











#### 并发问题

- 什么是线程安全问题
多线程环境多个线程访问共享资源时，由于线程调度的不确定性，可能导致不可预期的现象的情况

- 如何避免线程安全问题
 - 使用同步机制（即加锁）
 - 使用原子类、原子变量
 - 使用不可变对象
 - 线程变量隔离（ThreadLocal）
  

## 其他组件

### sql

#### mysql的索引有些哪些

- 主键索引
- 普通索引
- 联合索引
- 唯一索引

其中联合索引采用最左前缀原则

> 所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是，当遇到范围查询(>、<、between、like)就会停止匹配。





## 项目情景部分


### 如何提升接口的QPS
- 减少锁竞争
- 提高算法效率
- 异步处理
- 缓存策略（redis，本地缓存）
- 数据库优化（索引优化、SQL优化）
- 负载均衡
- 增加服务器资源





## AI相关


# 面试问题复盘

## JAVA部分

### 基础概念

- 重载和重写的区别
- 创建线程池的核心参数
- 单个线程的线程池有什么用处
  

### 使用

- Stream流的使用
  


### 进阶

#### 关于JDK的新特性

了解了一些关于JDK17的新特性
- switch增强，增强的switch可以作为表达式
- 文本块
- 模式匹配， instanceof 增强
- Records 类 创建不可变的数据载体类 它可以自动生成构造函数、getter方法、equals()、hashCode()和toString()方法等
- 密封类：限制了其他类或接口继承或者实现他的能力 `sealed`
- jdk17模块化机制
- 对于NPE报错的增强


#### 关于GC了解多少

##### 堆内存结构
在JDK8中，堆内存被分为年轻代和老年代。年轻代被进一步分为Eden区和Survivor区
创建对象时优先在年轻代中创建，在经历过多次（一般为16）垃圾回收后，将还存活的对象放入老年代
其中年轻代一般采用标记复制算法，由Eden区+其中一块Survivor区 与 另一块Survivor区做标记复制

##### 如何发现垃圾

- 引用计数算法
为每个对象维护一个引用计数器，每当有一个地方引用该对象时，计数器加一，引用失效计数器减一。当引用计数器为0时表示该对象不可达，即为垃圾对象。

存在问题： 无法处理循环引用的情况，两个对象相互引用但又没有外部引用，也不会被认为是垃圾对象

- 可达性分析算法
将所有的引用关系看作一张图（MAP）,从“GC ROOTs”出发开始向下搜索，搜索所走过的路径被称为引用链。 当一个对象到 GC ROOTS 没有任何引用链相连时，则该对象不可达，即为垃圾对象。
**GCRoots**： 虚拟机栈中的引用的对象，本地方法栈中引用的对象，方法区中静态变量引用的对象，常量引用的对象

##### 垃圾回收算法

- 标记-清除
分为标记和清除两个阶段。首先标记出所有[不]需要回收的对象（GCroots出发标记），标记完成后统一清理[没有]被标记的对象

存在问题： 清除后容易产生内存碎片

- 标记-复制
一般用在年轻代，将内存分为大小相等的两块，每次只使用其中一块。垃圾回收时，将还存活的对象复制到另一块内存上，然后将原来的内存一次性释放

存在问题：内存利用率不高，只有原来的一半。年轻代对象一般都是朝生夕死，这个缺点尚可接受

- 标记-整理
在标记-清除的基础加了一步整理，在标记完成后移动对象整理内存空间并回收垃圾对象

存在问题：效率不高，一般用在老年代


##### 垃圾收集器

###### CMS
工作流程：初始标记，并发标记，重新标记，并发清除
初始标记和重新标记都会触发stw
初始标记仅标记与GCRoots直接相连的对象stw较短
并发标记（三色标记法）和用户线程同时进行，不存在stw
重新标记 由于并发标记与用户线程同时进行可能会导致对象引用关系发生变化，重新标记来矫正这些变化，stw较短
并发清除 与用户线程同时进行，回收标记好的垃圾对象

存在问题：采用标记-清除算法，容易产生内存碎片，当碎片过多时可能会导致提前触发fullGC



###### G1

G1将堆内存分为多个大小相等的region，这些region不明确划分为年轻代和老年代，而是每个region都可以根据需要当成年轻代或是老年代的角色。

工作流程类似CMS
初始标记，并发标记，最终标记，筛选回收
其中 并发标记是基于region进行标记
筛选回收时，会根据用户设定的stw时间，对被扫描的区域做价值评估，优先回收部分区域，以满足stw时间的需求

回收时采用了标记-复制算法，直接从这块region复制到新的region，避免内存碎片的产生
另外对于大对象使用一块专门的region（属于老年代）存放，存储独立，被回收之前都不会移动。


存在问题： 如果gc时间设置的过短可能会频繁触发gc导致降低吞吐量


###### ZGC
ZGC的标记阶段由多个小阶段组成，部分小阶段需要暂停用户线程，但整体停顿时间较短
采用染色指针技术来进行标记，能够在更大的堆内存范围内高效的标记存活对象，并且尽量减少对应用程序的影响

初始标记，并发标记，再标记，并发转移准备，初始转移，并发转移

再标记：如果再并发标记阶段有新的对象被创建或有对象被回收，ZGC需要一次短暂的stw再标记，修正有于并发引起的标记不一致问题

并发转移准备：扫描整个堆，确定收集哪些Region，并将这些Region组成重分配集合。这里与G1不一样的是，ZGC会扫描所有的Region。 这个过程不是为了计算最优的回收集合，而是确定存活对象将被复制到其他Region

初始转移：核心阶段， ZGC并发地将重分配集合中存活的对象复制到新的Region。同时为了记录从旧对象到新对象的转移关系，ZGC需要为重分配集合中的每个Region维护一个转发表

并发转移： 修正堆中指向重分配集合中的旧对象的所有引用，真正对对象引用进行修复的一个步骤。











#### 并发问题

- 什么是线程安全问题
多线程环境多个线程访问共享资源时，由于线程调度的不确定性，可能导致不可预期的现象的情况

- 如何避免线程安全问题
 - 使用同步机制（即加锁）
 - 使用原子类、原子变量
 - 使用不可变对象
 - 线程变量隔离（ThreadLocal）
  

## 其他组件

### sql

#### mysql的索引有些哪些

- 主键索引
- 普通索引
- 联合索引
- 唯一索引

其中联合索引采用最左前缀原则

> 所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，值得注意的是，当遇到范围查询(>、<、between、like)就会停止匹配。


### 消息队列
知道消息队列的实现原理吗

#### 基本概念
1. 消息队列采用生产者、消费者模型。生产者将消息发送到消息队列，消费者从消息队列中获取消息并进行处理。
2. 解耦和异步，主要作用是应用程序之间的解耦和异步通信。生产者不需要知道消费者的细节，只需要将消息发送到消息队列；消费者也不需要知道生产者的细节，只需要从消息队列中获取消息；

#### 内部存储结构

- 持久化存储，在持久化消息队列中，消息通常会被存储在磁盘上以防止数据丢失。 
- 内存缓冲，消息队列会维护一定的内存缓冲区。当生产者发送消息时，消息首先被放入内存缓冲区，然后定期批量写入磁盘。对于消费者而言，优先读取内存缓冲区，然后再读取磁盘

#### 消息传递机制

1. 发布-订阅： 消息队列允许多个消费者订阅同一个主题（topic）。当消费者向topic发布消息时，消息会被广播给所有订阅该topic的消费者
2. 点对点，每个消息只能被一个消费者消费。消息队列确保消息只会被一个消费者接收并处理。

#### 可靠性保证

1. 消息确认机制： 消息队列通常具备消息确认机制，消费者在成功处理消息后，向消息队列发送确认信号。只有收到确认信号消息队列才会将消息标记为已消费并删除（非持久化）
2. 重试机制

#### 可用性

1. 主从
2. 分区和负载均衡


#### 如何实现

##### 整体架构
1. 明确架构：生产者-消费者架构
2. 消息存储结构： 采用阻塞队列，BlockingQueue，持久化则考虑落盘（写文件或者数据库）

##### 核心功能

1. 消息发布与订阅
   - 点对点模式： 创建一个队列类（包含一个阻塞队列）用于存储消息，生产者调用该类的produce发布消息，消费者通过consume方法从队列获取消息
   - 发布-订阅模型： 创建一个主题类，主题类维护一个消费者列表。当生产者向主题发布消息时，主题将消息广播给所有订阅的消费者

2. 持久化



## 项目情景部分


### 如何提升接口的QPS
- 减少锁竞争
- 提高算法效率
- 异步处理
- 缓存策略（redis，本地缓存）
- 数据库优化（索引优化、SQL优化）
- 负载均衡
- 增加服务器资源





## AI相关


# 问题复盘


### mysql 索引，B+树在删除数据时会做什么处理

#### B+树的特点（非innoDb 的存储结构）

- 根结点只有一个，分支数量为`[2,M]`,其中M为B+数的层数（阶数）
- 根节点以外的非叶子节点，每个节点分支包含`[[M/2],M]`个分支，其中 `[M/2]`为大于M/2的最小整数
- 所有非叶子节点的关键字数量等于的他的分支数
- 所有叶子节点都在同一层，且关键字数范围为`[M/2,M]`
- 所有非叶子节点的关键字可以看作索引的一部，他们的这些索引指向了他们子树最小或最大的关键字（要么都最小，要么都最大）
- 叶子节点包含所有关键字（即整行数据），所有关键字从小到大顺序连接

#### B+ 的删除 （新增则相反）

1. 定位待删除的元素，从根结点开始逐层比较关键字大小，确定查找路径，直到找到目标元素
2. 删除目标元素，删除后检查当前叶子节点是否满足最小要求（`[M/2]`），如果满足删除完成，如果不满足进入下一步
3. 处理节点下溢：
    - 向兄弟节点借元素： 如果相邻兄弟阶段元素量充足（大于`[M/2]`），向其借一个元素并修改父节点的分隔键
        例如：向右兄弟借一个最小值，并更新父节点中分隔键为新的最小值，删除完成
    - 合并兄弟节点：如果相邻兄弟节点元素不足，则当前节点与兄弟节点合并，并删除父节点中的分隔键，如果合并导致父节点元素不足
    需要递归处理父节点下溢
4. 递归处理父节点下溢：
    向兄弟节点借元素或者合并兄弟节点
    **递归终止条件：** 当前节点为根节点且关键字数量为空（此时树的高度降低一层），或节点满足最小关键字数量要求

##### 面试回答
B+树的删除过程从定位目标叶子节点开始。删除关键字后，若节点关键字不足，优先尝试向兄弟节点借元素；若兄弟节点也不足，则合并节点并递归处理父节点的下溢。整个过程需要维护B+树的平衡性和叶子节点的有序链表结构。此外，InnoDB的删除操作会标记空间为可复用，而非立即释放，以提高插入效率

#### InnoDb B+ 树
InnoDB的B+树 每个节点对应一个16Kb的数据页
- 对于非叶子节点： 仅存储索引页，存储内容为 主键（bigint，8字节） + 子节点指针（6字节）  =  14kB
    单节点最多可存储 =  16kB / 14B  约为 1170 个元素
- 叶子节点：如果为聚簇索引（主键索引）直接存储数据行（假设为1kB），如果是辅助索引（其他索引），存储 主键值（8字节）+ 指针（6字节）
    聚簇索引单节点最多元素行数 = 16KB / 1KB = 16
    辅助索引单节点最多元素数  约为 1170 

##### 关键结论

1. InnoDB非叶子节点容量：约1170个索引字段（主键+指针组合）
2. InnoDB叶子节点容量：
    - 存储数据行时：约16行（假设单行1KB）。
    - 存储辅助索引键值时：约1170个键值（与主键大小相关）。
3. 三阶B+树的理论与实现差异：
    InnoDB的B+树通过大页（16KB）和高扇出特性（每个节点存上千索引），使得3层即可支撑千万级数据，远高于传统“三阶”模型的容量。

**面试回答：** 三阶B+树理论中，非叶子节点最多存2个索引字段，叶子节点最多存3个元素。但InnoDB的实现中，每个节点对应16KB页：非叶子节点存主键+指针（约1170个），叶子节点若存数据行（假设1KB/行）则存16行，若存辅助索引键值则同样可存约1170个。三层B+树可支撑约2190万行数据。

**InnoDB优化：** 实际数据库通过高填充因子和延迟合并优化删除性能，避免频繁下溢处理




### netty的reactor模型是什么，你是怎么理解的？ 

1. Reactor模式的核心思想
Reactor模式通过事件驱动机制处理I/O操作，将I/O事件的监听与业务处理解耦。核心组件包括：
  - Reactor线程：负责监听和分发事件（如连接、读/写）。
  - Acceptor：处理新连接请求，创建对应的Handler。
  - Handler：执行非阻塞的I/O操作及业务逻辑。

2. Netty的线程模型：主从Reactor多线程
Netty采用主从Reactor多线程模型，通过两个线程组分工协作：
- BossGroup（主Reactor）：
    由多个EventLoop线程组成，仅负责监听和接受客户端连接。
    新连接建立后，将其注册到WorkerGroup中的某个子Reactor。
- WorkerGroup（子Reactor）：
    处理已建立连接的I/O操作（如读/写数据）。
    每个子Reactor线程独立运行，避免单线程性能瓶颈。
3. 对比其他Reactor模型的优化
- 单线程Reactor：
    所有操作（连接、I/O、业务）在一个线程完成，易因阻塞导致性能瓶颈。
- 单Reactor多线程：
    业务逻辑交由线程池处理，但I/O操作仍由单线程处理，高并发时I/O线程可能成为瓶颈。
- 主从Reactor多线程：
    连接与I/O操作分离：主Reactor处理连接，子Reactor处理I/O，最大化利用多核CPU。
    灵活扩展性：可根据并发量调整子Reactor数量，适合大规模高并发场景。
4. Netty的进一步优化
- 零拷贝机制：减少数据在内存中的复制次数，提升传输效率。
- 内存池管理：通过ByteBuf对象复用降低GC压力。
- 事件驱动与异步处理：通过ChannelPipeline和ChannelHandler链式处理事件，支持异步非阻塞。
5. 实际应用场景
- 高并发服务：如Dubbo、RocketMQ的底层通信，通过主从模型支持百万级连接。
- 协议适配：内置HTTP、WebSocket等协议栈，简化开发。



### @Transactional 事务

#### @Transactional 实现事务的核心机制
1. 动态代理和拦截器：
    Spring 通过 AOP 动态代理（JDK 或 CGLib）对 @Transactional 注解的方法生成代理对象，由 TransactionInterceptor 拦截目标方法的执行。在方法执行前，拦截器根据事务属性（如传播行为、隔离级别）决定是否创建新事务或加入已有事务，并通过 PlatformTransactionManager（如 DataSourceTransactionManager）与数据库交互
2. 事务传播行为控制：
    支持 7 种传播机制，例如：
    - REQUIRED（默认）：存在事务则加入，否则新建事务。如果A方法和B方法都添加了注解，此时，A方法内部调用B方法，会把两个方法的事务合并为一个事务 
    - REQUIRES_NEW：始终新建事务，挂起当前事务（适用于需独立提交的操作，如日志记录）。
    - NESTED：嵌套事务，允许部分回滚（依赖数据库支持，如 MySQL 的保存点
    - SUPPORTS： 如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行
    - NOT_SUPPORTED： 以非事务的方式运行，如果当前存在事务，暂停当前的事务
    - NEVER： 以非事务的方式运行，如果当前存在事务，则抛出异常
    - NESTED ：和 Propagation.REQUIRED 效果一样。
3. 资源绑定和线程隔离：
    事务使用的数据库连接通过 ThreadLocal 绑定到当前线程，确保同一事务内的所有数据库操作共享同一连接，避免多线程环境下事务混乱

#### 事务回滚的实现逻辑
1. 异常触发条件： 
    - 默认规则：仅当抛出 RuntimeException 或 Error 时回滚，检查型异常（如 IOException）不会触发回滚。
    - 自定义规则：通过 rollbackFor/noRollbackFor 指定需回滚的异常类型。例如，@Transactional(rollbackFor = Exception.class) 可使所有异常触发回滚
2. 底层回滚操作：
    事务管理器调用 JDBC Connection.rollback() 撤销未提交的数据库操作。
    若涉及多数据源或分布式事务，需通过 XA 协议或 Seata 等框架协调   
3. 资源清理和回调：
    Spring 通过 TransactionSynchronizationManager 管理事务状态，回滚时触发注册的回调（如释放线程绑定的连接、重置事务状态）

#### 关键注意事项（事务失效的场景）
1. 代理失效场景：
    - 非public方法：AOP仅拦截public方法
    - 自调用问题： 类内部方法调用（如 this.methodB() ）绕过代理，需通过 AopContext.currentProxy() 获取代理对象
    - 多线程问题： 子线程无法继承父线程事务上下文，需手动传递资源
2. 异常处理问题：
    若异常被 try-catch 捕获且未重新抛出，事务不会回滚。
    检查型异常需显式配置 rollbackFor 才能触发回滚

#### 总结

@Transactional 通过动态代理和事务管理器实现声明式事务，其核心在于代理拦截、传播行为控制和异常匹配机制。面试加分点：
- 明确区分 `检查型异常` 与 `非检查型异常` 的回滚规则。
- 强调 `自调用失效` 的底层原理（代理对象与目标对象分离）。
- 提及 `分布式事务` 的扩展方案（如 Seata 的 AT 模式）。

#### 扩展分布式事务

##### 什么是分布式事务
分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务

`本地事务`
```
begin transaction；
//1.本地数据库操作：我减少金额
//2.本地数据库操作：你增加金额
commit transation;
```
`分布式事务`
```
begin transaction；
//1.本地数据库操作：我减少金额
//2.远程调用：让你增加金额
commit transation;
```
##### 分布式事务产生的场景
1. 典型的场景就是微服务架构微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务
2. 单体系统访问多个数据库实例 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。 比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。 简言之：跨数据库实例产生分布式事务
3. 多服务访问同一个数据库实例 比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务

##### 使用seata解决分布式事务

seata架构
- TC (Transaction Coordinator) - 事务协调者
        维护全局和分支事务的状态，驱动全局事务提交或回滚。
- TM (Transaction Manager) - 事务管理器
        定义全局事务的范围：开始全局事务、提交或回滚全局事务。
- RM (Resource Manager) - 资源管理器
        管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态
        并驱动分支事务提交或回滚

seata模式
- AT（Automatic Transaction）：
    特点：
        自动补偿：基于支持本地 ACID 事务的关系型数据库。
        无侵入：业务代码无需关注事务的开启和关闭，框架自动处理。
        性能较高：通过记录业务数据的“快照”来达到事务回滚的目的，性能优于 TCC。
    工作原理：
        在业务操作前，Seata 会拦截业务 SQL，生成相应的回滚日志（undo log）并记录在数据库中。
        业务操作正常提交后，Seata 会删除这些 undo log。
        如果业务操作失败需要回滚，Seata 则根据 undo log 生成反向的 SQL 并执行，以达到数据回滚的效果。
- TCC（Try-Confirm-Cancel）：
    特点：
        强一致性：适用于对事务一致性要求极高的场景。
        业务侵入性：需要业务代码配合实现三个阶段（Try、Confirm、Cancel）。
        灵活性：可以针对特定资源进行精确控制。
    工作原理：
        Try 阶段：尝试执行业务操作，完成所有业务检查（一致性）。
        Confirm 阶段：确认执行业务操作。
        Cancel 阶段：取消执行业务操作。
- SAGA：
    特点：
        长事务解决方案：适用于业务流程长且跨越多个服务的情况。
        事件驱动：通过事件驱动的方式来实现分布式事务的最终一致性。
        灵活性强：可以针对不同的服务设计不同的补偿策略。
    工作原理：
        将一个长事务拆分成多个本地事务（每个本地事务可以由不同的服务处理）。
        每个本地事务执行成功后，发布一个事件；其他服务监听这些事件并执行相应的逻辑。
        如果某个本地事务失败，可以通过一系列的补偿动作来逐步回滚到一致状态
- XA（）： 
    特点：
        标准协议：基于 X/Open XA 规范实现。
        强一致性：保证事务的强一致性。
        资源限制：仅支持支持 XA 协议的数据库。
    工作原理：
        使用 XA 协议来管理全局事务和本地事务的关系。
        全局事务管理器协调多个分支事务，确保所有分支事务要么全部提交，要么全部回滚。
        需要数据库和中间件同时支持 XA 协议

###### seata AT 模式实现
- 一阶段：Seata 会拦截" 业务SQL"，解析 SQL 语义
    查询 “业务SQL” 要更新的业务数据，在业务数据被更新前，将其保存成 “before image”
    执行 “业务SQL” ，更新业务数据
    查询更新后的数据，将其保存成 “after image”
    将 before image 和 after image 保存至 Undo Log 表中
    生成行锁
    以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

- 二阶段（提交）：
    因为 “业务SQL” 在一阶段已经提交至数据库，所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。

- 二阶段（回滚）：
    首先要校验脏写，对比“数据库当前业务数据”和 “after image”
    如果两份数据完全一致就说明没有脏写，可以还原业务数据。
    如果不一致就说明有脏写，出现脏写就需要转人工处理。
    用“before image”还原业务数据
    删除快照数据和行锁


###### 配置seata  
配置seata然后将 @Transactional 替换为 @GlobalTransactional



# 面试复盘3



## HashMap的底层数据结构是什么？

HashMap的底层数据结构主要是哈希表，具体是基于数组+链表+红黑树实现的。 
在Java8之前，HashMap使用数组+链表来解决Hash冲突 （拉链法）
java8之后引入了红黑树进行优化。当数组长度（一般为64）和链表长度超过阈值（一般为8），链表会转换为红黑树，提高查询效率； 红黑树节点少于6，红黑树又会退化为链表

### 追问1  HashMap的扩容机制是什么？为什么容量翻倍是两倍？

HashMap的扩容机制是当HashMap中的元素数量超过容量和负载因子（默认为0.75）的乘积时，就会触发扩容操作，扩容后的HashMap容量为原来的2倍
选择两倍扩容的原因：
- 提升运算效率： 两倍扩容可以采用位运算，左移动一位即可扩大两倍
- 方便元素重新分布： 扩容后，原来位置上的元素要么在原位置，要么在“原索引+旧容量”的位置上

### 追问2  红黑树有什么特点？

红黑树是一种平衡排序树，左子节点比父节点小，右子节点比父节点大。它具有自平衡功能，能将长链表的O(n)查找时间复杂度优化为O(log n)，加快查询效率
具体的平衡规则：
- 根节点是黑色的；所有的叶子节点（Nil空的，用于标识边界的节点）是黑色
- 其他节点是黑色或者红色的
- 红色节点的子节点必须是黑色的。 为了避免出现连续的红色节点。导致严重不平衡
- 从任一节点到其每一个叶子节点的所有路径包含相同数量的黑色节点。（确保树的平衡，让查询、插入、删除的时间复杂度维持在较低的水平 O(logN)）



## Java并发包（juc）中的工具用过哪些？

用过一些，比如异步调用方面，主要使用CompletableFuture进行统一的异步调用，它可以方便地处理异步任务的结果和组合多个异步任务。
同步锁方面用过 ReentrantLock，这个JDK提供的可重入的互斥锁，相比synchronized更加灵活；还有用过CountDownLatch信号量，它可以让一个或多个线程等待其他线程完成操作；
然后还有用到过线程池和ConcurrentHashMap、CopyOnWriteArrayList等线程安全的对象集合
另外还了解一些阻塞队列BlockingQueue之类的工具

### 追问1  synchronized关键字与ReentrantLock有什么区别？ 

- 语法
  - synchronized 是 java内置的关键字使用较为简洁，可以修复方法和代码块。 锁的获取和释放都是自动完成的。
  - ReentrantLock 是一个由JDK提供的类，需要手动创建实例，并且必须手动释放锁（一般在finally块），以确保在发生异常时锁能被正确释放。
- 锁的获取和释放
  - synchronized 由JVM自动完成锁的获取和释放，无需开发者干预。在进入同步方法或代码块时，线程自动获取锁；退出时，自动释放锁。
  - ReentrantLock 需要手动调用 `lock` 和`unlock`方法来获取和释放锁，更加灵活的同时增加了一定的风险
- 锁的特性
  - 可中断性
    - synchronized 获取的锁不可中断，如果线程在等待锁，它将一直等待直到获取到锁或者发生异常
    - ReentrantLock 提供了可中断锁的获取方式，通过`lockInterruptibly`方法获取可中断的锁，会响应thread.interrupt()，而 `synchronized`或`lock`只会在获取到锁之后响应中断
  - 公平性
    - synchronized 是非公平锁，多个线程竞争锁时，每个线程获取锁的机会是随机的，不会按照申请锁的顺序分配锁。
    - ReentrantLock 提供了公平锁和非公平锁的创建方式，可以通过构造方法(true)来创建公平锁，保证按照线程申请锁的顺序获取锁。
  - 锁的粒度和灵活性
    - synchronized 粒度通常较大，一般以方法或者代码块为单位，不够灵活。在复杂场景中会导致不必要的线程阻塞
    - ReentrantLock 可以实现更加细粒度的锁控制，如 使用`trylock`尝试获取锁，根据返回作不同处理，减少线程等待
  - 性能
    - synchronized 在jdk1.6之前性能较差，因为它是重量级锁，JDK 1.6及以后，JVM对synchronized进行了大量优化，引入了锁升级过程，如偏向锁、轻量级锁等，使得它的性能有了很大提升，在无多线程竞争的情况性能高于 ReentrantLock
    - ReentrantLock 在高并发和复杂锁控制的场景下，由于其灵活的锁特性，可能会表现出更好的性能。
  
  测试代码
  ```java
    private static final long ITERATIONS = 100_000_000_00L;

    public static void main(String[] args) throws InterruptedException {
        testSynchronized();
        testReentrantLock();
    }

    private static void testSynchronized() throws InterruptedException {
        long start = System.nanoTime();
        synchronizedMethod(ITERATIONS);
        long end = System.nanoTime();
        System.out.println("Synchronized: " + TimeUnit.NANOSECONDS.toMillis(end - start) + " ms");
    }

    private static void testReentrantLock() throws InterruptedException {
        ReentrantLock lock = new ReentrantLock();
        long start = System.nanoTime();
        reentrantLockMethod(lock, ITERATIONS);
        long end = System.nanoTime();
        System.out.println("ReentrantLock: " + TimeUnit.NANOSECONDS.toMillis(end - start) + " ms");
    }

    private static void synchronizedMethod(long iterations) {
        synchronized ("NewAdRealRevokeJob.class") {
            long a = 0;
            for (long i = 0; i < iterations; i++) {
                a   ++;
            }
            System.out.println(a);
        }
    }

    private static void reentrantLockMethod(ReentrantLock lock, long iterations) {
        lock.lock();
        long a = 0;
        try {
            for (long i = 0; i < iterations; i++) {
                a   ++;
            }
            System.out.println(a);
        } finally {
            lock.unlock();
        }
    }
  ```

## Java虚拟机中堆和栈有什么区别？

堆是Java对象的实际存储位置，是线程共享的区域
在堆中内存的分配和释放需要手动申请（通过代码创建对象），堆的垃圾回收（GC）机制决定对象的生命周期。
堆的空间通常较大，能够容纳大量的对象实例。

栈是每个线程独立的空间，为每个方法分配栈空间。 栈上的引用指向堆里的对象。
栈的内存分配由编译器自动完成，当方法执行时，会为其分配栈帧用于存储局部变量、方法参数、返回值等信息；
方法执行完成后，栈空间会被自动销毁，他的生命周期随方法的结束而结束。
栈空间相对较小，并且由于其先进后出的特性，不会产生内存碎片，所以栈的分配效率高于堆。

### 附加：你知道逃逸分析吗？ 还有什么是线程本地缓存

- 逃逸分析：逃逸分析是JVM的一种优化技术，用于分析对象的作用域和生命周期，判断对象是否可能被外部方法或线程引用，从而决定是否需要在堆上分配内存。
  - 形式：
    - 方法逃逸： 对象作为参数传递给其他方法，或者通过方法返回值暴露给外部
    - 线程逃逸： 对象被多个线程共享访问（如赋值给全局变量）
  - 优化策略：如果对象未发生逃逸，JIT编译器会采取以下优化：
    - 栈上分配： 将对象直接分配在栈内存上，随方法结束自动销毁，减少不必要的堆内存占用和GC压力
    - 锁消除： 如果对象仅被单个线程方法访问，JVM自动移除不必要的同步锁
    - 标量替换： 将对象拆解为基本类型变量，直接在栈上分配，避免创建完整对象
  - 应用和限制
    - 默认开启：jdk6之后默认开启（-XX:+DoEscapeAnalysis）逃逸分析
    - 局限：仅适用于生命周期短且未逃逸的小对象，复杂逃逸场景仍需堆分配
- 线程本地缓存（TLAB）: TLAB是JVM堆内存为每个线程分配的私有内存区域（位于Eden区），用于优化多线程环境下对象分配的效率。
  - 作用：
    - 减少锁竞争：线程在私有TLAB区域分配对象时无需全局锁，避免了多线程竞争导致性能损耗
    - 降低内存碎片：通过线程本地分配，减少频繁CAS操作引发的指针碰撞问题
  - TLAB的配置和优化：
    - 默认开启： JVM默认开启TLAB（-XX:+UseTLAB）,且TLAB大小占Eden区1% （通过-XX:TLABSize调整）
    - 空间浪费问题: 如果对象大小略大于TLAB剩余空间，会触发慢速路径分配； 过小的TLAB可能导致频繁的内存申请
  - TLAB与逃逸分析的协同：
    - 如果对象未逃逸且适合栈分配，优先使用栈空间；否则在TLAB中分配

总结对比
| 特性               | 逃逸分析                          | TLAB                              |
|--------------------|-----------------------------------|-----------------------------------|
| 主要目标       | 减少堆内存分配和GC压力            | 优化多线程对象分配效率            |
| 作用范围       | 方法级别，分析对象生命周期         | 线程级别，分配私有内存区域         |
| 优化手段       | 栈分配、锁消除、标量替换          | 线程本地无锁分配                  |
| 适用场景       | 短生命周期、未逃逸的小对象         | 所有线程内部分配的对象            |


## 垃圾回收用到了什么样的回收机制？

垃圾回收主要通过垃圾收集器（GC）来实现。
判断对象是否可回收的方法主要有引用计数器（已淘汰）和可达性分析法。现在主要使用可达性分析法，即从GC Roots 出发标记所有可达对象，然后清理其他未标记对象。

常见的垃圾回收算法有
- 标记-清除
- 标记-复制
- 标记-整理
- 分代收集算法

常见的垃圾收集器有：
- CMS
- G1
- ZGC
  
此外，内存分配与回收也有相应策略，比如对象优先在Eden区分配，大对象直接进入老年代，长期存活的对象进入老年代等


## 遇到内存溢出问题，有哪些排查方式？

这种情况可以分类讨论
- 如果程序已经崩溃：
可以通过jmap分析dump文件，前提是启动时添加了相关的JVM参数保存dump文件（XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=路径）
还可以使用MAT、JProfile、VisualVM等工具分析dump文件

- 程序仍在运行：
如果程序还在运行，可以使用jstack、jmap打印内存和GC情况。或者使用JVisualVM、arthes等工具远程连接定位问题发生的位置
还可以使用jstat查看GC状态。 

定位到问题之后，还需要结合代码进一步分析可能的内存泄露点：
- 是否存在未关闭的资源
- 过大的缓存
- 线程未正确关闭
根据分析结果优化代码并验证


## Spring框架中AOP是什么概念，一般用在什么场景？

AOP（面向切面编程）是通过预编译和运行时动态代理是实现程序功能统一维护的技术。
核心思想在于将那些于核心业务逻辑无关但又会在多个模块中重复出现的关注点，比如日志记录、安全检查、事务管理等从业务逻辑中分离出来
让业务逻辑更加存粹，提高代码的可维护性和可扩展性

常见场景：
- 事务管理： 借助@Transactional注解，方便的对数据库事务进行管理，确保数据操作的完整性和一致性
- 日志记录： 对于方法调用的情况、输入输出以及返回值等的检查和记录
- 权限验证： 执行某些方法前，检查用户是否具备相应的权限
- 性能监控： 统计方法的执行时间等
- 缓存控制： 对方法的返回值进行缓存，下次调用相同方法时，可以直接从缓存获取结果，提高响应速度
- 异常处理： 对于特定的异常进行统一的处理，避免在每个业务方法中重复编写异常处理代码
  
AOP核心概念：
- 切面（Aspect）: 指横切关注点的模块化，它封装了通知和切点
- 连接点（JoinPoint）: 表示程序执行过程中可以插入切面的点，例如方法调用、异常抛出等
- 通知（Advice）: 定义了在连接点上执行的操作，包括前置通知、后置通知、环绕通知等
- 切点（Pointcut）: 用于定义哪些连接点会被增强，它通过特定的表达式来匹配连接点

### 追问1 AOP底层有哪些实现方式？

AOP底层主要有两种是实现方式：
- 基于JDK的动态代理
  - 基于接口实现的动态代理，调用代理对象的方法时会自动调用invoke方法，这里面可以做一些增强
- 基于CGLib的动态代理
  - 通过继承目标对象来创建代理对象，在运行时动态生成目标类的子类，重写父类的方法，再重写方法中可以添加额外的逻辑

两种实现方式对比
- 性能方面：在创建代理对象时，JDK动态代理的速度相对较快，因为它是基于接口实现的，不需要生成新的类；而CGLIB代理需要生成目标类的子类，创建代理对象的速度相对较慢。但在调用代理对象的方法时，CGLIB代理的性能要优于JDK动态代理。
- 适用场景方面：如果目标对象实现了接口，优先使用JDK动态代理；如果目标对象没有实现接口，则只能使用CGLIB代理。

### 追问2  有没有用过编译期做字节码增强的工具？

- Lombok：通过注解在编译期生成getter/setter、toString等方法
- MapStruct： 主要用于对象类型转换，在编译期生成属性拷贝的方法，相比Spring提供的拷贝方法效率更高
- AspectJ：提供编译期织入AOP功能，比Spring AOP性能更好；
- ByteBuddy：（类似CGLib）简化字节码生成和操作的库；


## MySQL常用的存储引擎有哪些？它们有什么区别？

MySQL主要使用InnoDB和MyISAM两种存储引擎。InnoDB使用聚簇索引，主键索引上直接带有数据；而MyISAM的索引与数据分开存储，所有索引节点存储的是引用，指向单独的数据文件。
另外还有 Memory（数据存储在内存中，速度快但不持久，适合临时表） 、 Archive（高压缩比，适合归档数据） 和 NDB（MySQL集群存储引擎，适合高可用场景） 
mysql5.5之后默认使用InnoDB


## 数据库索引规划有哪些常用方案？

数据库索引规划原则：
1. 频繁作为查询条件的字段应创建索引；
2. 唯一性太差的字段不适合单独创建索引(如性别)；
3. 频繁更新的字段不适合创建索引；
4. 不会出现在WHERE子句中的字段不应创建索引；
5. 联合索引遵循最左前缀原则，把区分度高的字段放在前面；
6. 覆盖索引可减少回表操作，提高查询效率；
7. 避免冗余索引和过多索引(影响写性能)；
8. 考虑使用前缀索引降低索引空间；
9. 大表考虑分区和分表策略；1
10. 定期分析和优化索引，删除无用索引。

### 追问1：  对查询优化有什么经验？

曾遇到一个涉及10张表的复杂慢查询，将其拆分成多个只join一两张表的简单查询，然后在代码层面处理业务逻辑和数据组装。这样既可以并发查询减少响应时间，又避免了复杂SQL的性能问题

#### 补充：
SQL查询优化经验：
1. 索引优化：合理设计和使用索引，避免索引失效情况；
2. SQL语句优化：只查询需要的字段，避免SELECT *；使用LIMIT限制结果集；避免使用OR、IN、NOT IN等可能导致全表扫描的操作；
3. JOIN优化：减少JOIN表数量，小表驱动大表，使用索引列关联；
4. 子查询优化：尽量使用JOIN代替子查询；
5. 分页优化：使用覆盖索引和延迟关联优化大偏移量分页；
6. 批量操作：使用批量插入代替单条插入；
7. 数据库设计：适当冗余字段减少JOIN；
8. 缓存利用：使用应用缓存或数据库查询缓存；
9. 分库分表：对于超大表考虑水平/垂直拆分；
10. 执行计划分析：使用EXPLAIN分析SQL执行计划，找出性能瓶颈。


## ES在什么业务场景下使用？存储的数据量多大？

ES主要用于两个场景：一是流程变更记录的搜索查询；二是AI知识库应用。AI知识库中ES既支持BM25算法根据关键字匹配，又支持向量存储，可以同时存储文档的向量化数据和关键词索引，加强知识库搜索能力。

### 补充
ElasticSearch常见应用场景：
1. 全文搜索：产品搜索、文档搜索、日志搜索等；
2. 日志分析：ELK/EFK架构收集、存储和分析日志；
3. 指标监控：存储和分析系统监控指标；
4. 安全分析：异常行为检测；
5. 业务分析：用户行为分析、BI报表；
6. 向量搜索：AI应用中的语义搜索、相似度搜索；
7. 地理位置搜索：附近的人/店铺等。ES适合处理TB甚至PB级别的数据，通过分片和集群实现水平扩展。优化ES性能需考虑：合理的索引设计、分片策略、查询优化、硬件配置和集群规模等。


## 消息中间件主要做什么用途？如何保证消息幂等性？

主要用于多服务间的数据传输。保证消息幂等性可以通过消息确认机制，确认过的消息就删除；或者使用类似位图的方式标记已处理过的消息，避免重复处理

### 补充
消息中间件主要用途：
1. 异步处理：非核心流程异步化，提高系统响应速度；
2. 应用解耦：生产者和消费者松耦合；
3. 流量削峰：缓冲突发流量；
4. 可靠通信：保证消息可靠投递；
5. 广播通知：一对多消息分发；
6. 事件驱动架构：基于事件的系统集成。
保证消息幂等性的方法：
1. 唯一ID策略：为每条消息生成全局唯一ID，消费前检查是否处理过；
2. 业务唯一标识：使用业务字段组合作为唯一标识；
3. 版本号/状态机：使用版本号或状态变更控制；
4. 分布式锁：处理前获取锁；
5. 去重表：记录已处理的消息ID；
6. 幂等设计：将非幂等操作设计为幂等(如UPDATE替代INSERT)。

常见消息中间件包括：Kafka、RabbitMQ、RocketMQ、ActiveMQ等。


## Redis在什么场景下使用？如何处理热点数据？

主要用于缓存接口查询结果、报表数据和实现简单的分布式锁。对于热点数据，可以先做预热，将预判的热点数据提前放入缓存；对于首次访问的数据，先从数据库获取后放入缓存，并统计访问次数，用于下一轮预热的参考。


### 补充

Redis常见应用场景：
1. 缓存：减轻数据库压力，提高响应速度；
2. 计数器：高性能计数(如访问量统计)；
3. 限流：接口限流防止过载；
4. 分布式锁：并发控制；
5. 排行榜：利用Sorted Set实现；
6. 会话存储：存储用户会话；
7. 消息队列：轻量级消息队列；
8. 地理位置：基于GEO类型的位置应用。

热点数据处理策略：
1. 数据预热：系统上线前预先加载热点数据；
2. 合理过期策略：热点数据设置更长过期时间或永不过期；
3. 分布式缓存集群：使用Redis Cluster分散热点数据；
4. 二级缓存：本地缓存+Redis缓存；
5. 读写分离：主从架构分担读压力；
6. 热点数据分片：将热点key拆分为多个子key；
7. 布隆过滤器：减少缓存穿透；
8. 缓存更新策略：合理选择更新策略(Cache Aside、Read/Write Through、Write Behind)。



## AI项目的经验如何应用在其他方面？

从零开始学习，先了解资料和文档，实现一个最小demo，然后在此基础上扩展。
完成扩展后，再审视整个架构，判断是否合理。
有了最小架构基础，可以快速实现更完善的架构。
这个从了解、尝试、扩展到完整构建的过程不仅适用于AI，也适用于其他技术学习。

### 补充
AI项目学习与实践方法：
1. 打好基础：了解AI基本概念、算法原理和主流框架；
2. 选择合适切入点：从特定领域(如NLP、计算机视觉)或特定应用(如聊天机器人)入手；
3. 实践驱动学习：从小项目开始，逐步扩展；
4. MVP(最小可行产品)思想：先实现核心功能，再迭代完善；
5. 利用开源资源：使用开源模型、数据集和工具加速开发；
6. 关注工程实践：数据处理、模型部署、性能优化等；
7. 持续学习：跟踪领域最新进展；
8. 参与社区：与其他开发者交流经验；
9. 结合业务场景：将AI技术与实际业务需求结合；
10. 注重评估与反馈：建立合理的评估指标，根据反馈持续优化。


